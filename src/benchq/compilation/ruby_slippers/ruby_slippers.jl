################################################################################
# © Copyright 2022-2023 Zapata Computing Inc.
################################################################################
#=
This module contains functions for getting the graph state corresponding to a
state generated by a circuit using a graph state simulator (graph_sim) from the paper
"Fast simulation of stabilizer circuits using a graph state representation" by Simon
Anders, Hans J. Briegel. https://arxiv.org/abs/quant-ph/0504117". We have modified
the algorithm to ignore paulis.

Many of the modules have a no_teleport version. This is to denote that the compiler
does not use teleportation in these cases and is more or less just it's predicessor,
a graph simulator for stabilizer states.
=#

using PythonCall
import Pkg
Pkg.add("StatsBase")
using StatsBase


const Qubit = UInt32
const AdjList = Set{Qubit}

"""
Destructively convert this to a Python adjacency list
"""
function python_adjlist!(adj)
    pylist([pylist(adj[i] .- 1) for i = 1:length(adj)])
end


include("graph_sim_data.jl")
include("pauli_tracker.jl")

struct ICMOp
    code::UInt8
    qubit1::Qubit
    qubit2::Qubit
    angle::Float64

    ICMOp(code, qubit) = new(code, qubit, 0, 0)
    ICMOp(code, qubit1, qubit2) = new(code, qubit1, qubit2, 0)
    ICMOp(code, qubit1, qubit2, angle) = new(code, qubit1, qubit2, angle)
end
RZOp(qubit1, angle) = ICMOp(RZ_code, qubit1, 0, angle)

struct RubySlippersHyperparams
    teleportation_threshold::UInt16
    teleportation_distance::UInt8
    min_neighbors::UInt8
    max_num_neighbors_to_search::UInt32
    decomposition_strategy::UInt8 # TODO: make pauli tracker work witn decomposition_strategy=1
end

default_hyperparams = RubySlippersHyperparams(3, 4, 6, 1e5, 0)
graphsim_hyperparams(min_neighbors, max_num_neighbors_to_search) = RubySlippersHyperparams(65535, 2, min_neighbors, max_num_neighbors_to_search, 0)
default_graphsim_hyperparams = graphsim_hyperparams(6, 1e5)

include("algorithm_specific_graph.jl")
include("asg_stitching.jl")

"""
Converts a given circuit in Clifford + T form to icm form and simulates the icm
circuit using the graph sim mini simulator. Returns the adjacency list of the graph
state created by the icm circuit along with the single qubit operations on each vertex.
teleportation_threshold, min_neighbors, teleportation_distance, and  max_num_neighbors_to_search
are metaparameters which can be optimized to speed up the simulation.

Args:
    circuit::Circuit                  circuit to be simulated
    max_graph_size::Int               maximum number of nodes in the graph state
    teleportation_threshold::Int      max node degree allowed before state is teleported
    teleportation_distance::Int       number of teleportations to do when state is teleported
    min_neighbors::Int                stop searching for neighbor with low degree if
                                        neighbor has at least this many neighbors
    max_num_neighbors_to_search::Int  max number of neighbors to search through when finding
                                        a neighbor with low degree
    decomposition_strategy::Int       strategy for decomposing non-clifford gate
                                        0: keep current qubit as data qubit
                                        1: teleport data to new qubit which becomes data qubit

Returns:
    adj::Vector{AdjList}              adjacency list describing the graph state
    sqs::Vector{UInt8}                  single qubit clifford operations on each node
"""
function run_ruby_slippers(
    circuit,
    verbose=false,
    max_graph_size=nothing,
    teleportation_threshold=40,
    teleportation_distance=4,
    min_neighbors=6,
    max_num_neighbors_to_search=1e5,
    decomposition_strategy=1,
    max_time=1e8
)
    # params which can be optimized to speed up computation
    hyperparams = RubySlippersHyperparams(
        teleportation_threshold,
        teleportation_distance,
        min_neighbors,
        max_num_neighbors_to_search,
        decomposition_strategy,
    )

    if max_graph_size === nothing
        max_graph_size = get_max_n_nodes(circuit, hyperparams.teleportation_distance)
    else
        max_graph_size = pyconvert(UInt32, max_graph_size)
    end

    if verbose
        # print("get_graph_state_data:\t")
        (sqc, adj, proportion) = @time get_graph_state_data(circuit, true, max_graph_size, hyperparams, max_time)
    else
        (sqc, adj, proportion) = get_graph_state_data(circuit, false, max_graph_size, hyperparams, max_time)
    end
    return pylist(sqc), python_adjlist!(adj), proportion
end

function get_max_n_nodes(circuit, teleportation_distance)
    supported_ops = get_op_list()

    n_magic_state_injection_teleports = 0
    n_ruby_slippers_teleports = 0

    for op in circuit.operations
        if occursin("ResetOperation", pyconvert(String, op.__str__()))
            n_magic_state_injection_teleports += 1
            continue
        else
            op_index = get_op_index(supported_ops, op)
            if double_qubit_op(op_index)
                n_ruby_slippers_teleports += 2
            elseif decompose_op(op_index)
                n_magic_state_injection_teleports += 1
                n_ruby_slippers_teleports += 1
            end
        end
    end

    return convert(UInt32, n_magic_state_injection_teleports +
                           n_ruby_slippers_teleports * teleportation_distance +
                           pyconvert(Int, circuit.n_qubits))
end

"""
Get the vertices of a graph state corresponding to enacting the given circuit
on the |0> state. Also gives the single qubit clifford operation on each node.

Args:
    circuit (Circuit): orquestra circuit circuit to get the graph state for
    verbose (Bool): whether to print progress
    hyperparams (Dict): metaparameters for the ruby slippers algorithm see
                        description in run_ruby_slippers for more details

Raises:
    ValueError: if an unsupported gate is encountered

Returns:
    Vector{UInt8}: the list of single qubit clifford operations on each node
    Vector{AdjList}:   the adjacency list describing the graph corresponding to the graph state
"""
function get_graph_state_data(
    orquestra_circuit,
    n_qubits,
    takes_graph_input::Bool=true,
    gives_graph_output::Bool=true,
    verbose::Bool=true,
    max_graph_size::Int64=1e7,
    max_time::Float64=1e8,
    layering_optimization::String="ST-Volume",
    hyperparams::RubySlippersHyperparams=default_hyperparams,
)
    println("First n_qubits: ", n_qubits)
    if takes_graph_input
        asg, pauli_tracker = initialize_for_graph_input(max_graph_size, n_qubits, layering_optimization)
    else
        asg = AlgorithmSpecificGraphAllZero(max_graph_size, n_qubits)
        pauli_tracker = PauliTracker(n_qubits, layering_optimization)
    end

    total_length = length(orquestra_circuit)
    counter = dispcnt = 0
    erase = "        \b\b\b\b\b\b\b\b"
    start_time = time()

    for (counter, op) in enumerate(orquestra_circuit)
        elapsed_time = time() - start_time
        # End early if we have exceeded the max time
        if elapsed_time >= max_time
            delete_excess_asg_space!(asg)
            percent = counter / total_length
            return asg.sqs, asg.edge_data, percent
        end

        # Show progress of compilation in real time
        if verbose
            if (dispcnt += 1) >= 1000
                percent = round(Int, 100 * counter / total_length)
                display_elapsed = round(elapsed_time, digits=2)
                print("\r$(percent)% ($counter) completed in $erase$(display_elapsed)s")
                dispcnt = 0
            end
        end

        # Apply current operation
        if occursin("ResetOperation", pyconvert(String, op.__str__())) # reset operation
            asg.n_nodes += 1
            data_qubits[get_qubit_1(op)] = asg.n_nodes
            continue
        else
            op = get_op_from_orquestra_gate(op)

            # println("applying operation ", op, " with data nodes ", asg.stitching_properties.gate_output_nodes)
            if op.code in non_clifford_gate_codes
                apply_non_clifford_gate!(asg, pauli_tracker, op, hyperparams)
            elseif op.code in [I_code, X_code, Y_code, Z_code, H_code, S_code] # single qubit clifford gates
                op_code = op.code
                node = asg.stitching_properties.gate_output_nodes[op.qubit1] # node this operation with act on
                if op_code in [I_code, X_code, Y_code, Z_code]
                    asg.sqp[node] = multiply_sqp[asg.sqp[node], external_to_internal_paulis[op_code]]
                elseif op_code == H_code
                    multiply_h_from_left(asg, pauli_tracker, node)
                elseif op_code == S_code
                    multiply_s_from_left(asg, pauli_tracker, node)
                end
            elseif op.code in [CZ_code, CNOT_code] # two qubit clifford gates
                op_code = op.code
                node_1 = asg.stitching_properties.gate_output_nodes[op.qubit1]
                node_2 = asg.stitching_properties.gate_output_nodes[op.qubit2]
                if op_code == CNOT_code
                    # CNOT = (I ⊗ H) CZ (I ⊗ H)
                    multiply_h_from_left(asg, pauli_tracker, node_2)
                    cz(asg, node_1, node_2, pauli_tracker, hyperparams)
                    # update node_2 to the new qubit if previous cz teleported it
                    node_2 = asg.stitching_properties.gate_output_nodes[op.qubit2]
                    multiply_h_from_left(asg, pauli_tracker, node_2)
                elseif op_code == CZ_code
                    cz(asg, node_1, node_2, pauli_tracker, hyperparams)
                end
            else
                error("Unsupported gate: $(op.code)")
            end
        end
    end

    if verbose
        elapsed = round(time() - start_time, digits=2)
        println("\r100% ($counter) completed in $erase$(elapsed)s")
    end

    # add teleportations at end so we can connect to next buffer
    nodes_to_remove = Set([])
    if gives_graph_output
        add_output_nodes!(asg, pauli_tracker, nodes_to_remove)
    end
    if takes_graph_input
        prune_buffer!(asg, pauli_tracker, n_qubits, nodes_to_remove)
    end

    calculate_layering!(pauli_tracker, asg, nodes_to_remove)

    println("nodes to remove (first): ", nodes_to_remove)

    delete_excess_asg_space!(asg)
    asg, pauli_tracker = minimize_node_labels!(asg, pauli_tracker, nodes_to_remove)

    println(pauli_tracker)
    println()
    println(asg)
    println()
    println()
    return asg, pauli_tracker
end

"""
Implement non-clifford gates via gate teleportation as described in
https://arxiv.org/abs/1509.02004. This is commonly reffered to as the ICM
format.
"""
function apply_non_clifford_gate!(asg, pauli_tracker, op, hyperparams)
    original_qubit = op.qubit1 # qubit the T gate was originally acting on before ICM
    asg.n_nodes += 1
    # println(compiled_qubit, " -> ", asg.n_nodes, " ")
    # TODO: implement different decomposition_strategies with new tracker
    original_node = Qubit(asg.stitching_properties.gate_output_nodes[original_qubit])
    compiled_node = Qubit(asg.n_nodes)
    # add new qubit to be tracked
    add_new_qubit_to_pauli_tracker!(pauli_tracker)
    # apply CX
    multiply_h_from_left(asg, pauli_tracker, compiled_node)
    cz_no_teleport(asg, original_node, compiled_node, pauli_tracker, hyperparams)
    # update original_node to the new qubit if that cz teleported it
    original_node = Qubit(asg.stitching_properties.gate_output_nodes[original_qubit])
    multiply_h_from_left(asg, pauli_tracker, compiled_node)
    # mark compiled qubit as where the data is being stored
    if hyperparams.decomposition_strategy == 0
        asg.stitching_properties.gate_output_nodes[original_qubit] = compiled_node
    end
    # Update pauli Tracker
    add_z_to_pauli_tracker!(pauli_tracker.cond_paulis, original_node, compiled_node)
    if op.code == RZ_code
        add_measurement!(pauli_tracker.measurements, op.code, original_node, op.angle)
    else
        add_measurement!(pauli_tracker.measurements, op.code, original_node)
    end
end

"""
Delete excess parts of the ASG to save space once we have completed
the computation. This is done by resizing the vectors to only contain
the nodes which are actually used in the graph state.
"""
function delete_excess_asg_space!(asg)
    resize!(asg.edge_data, asg.n_nodes)
    resize!(asg.sqs, asg.n_nodes)
    resize!(asg.sqp, asg.n_nodes)
end

"""
Check if a vertex is almost isolated. A vertex is almost isolated if it has no
neighbors or if it has one neighbor and that neighbor is the given vertex.

Args:
    set::AdjList set of neighbors of a vertex
    vertex::Int  vertex to check if it is almost isolated

Returns:
    Bool: whether the vertex is almost isolated
"""
function check_almost_isolated(set, vertex)
    len = length(set)
    return (len == 0) || (len == 1 && vertex in set)
end

"""
Apply a CZ gate to the graph on the given vertices.

Args:
    sqs::Vector{UInt8}      single qubit clifford operation on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         vertex to enact the CZ gate on
    vertex_2::Int         vertex to enact the CZ gate on
"""
function cz(asg, vertex_1, vertex_2, pauli_tracker, hyperparams)
    # println("\nStarting applying cz on qubits $(vertex_1) and $(vertex_2)! the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n pauli       $(asg.sqp)!")
    # println(asg.stitching_properties.gate_output_nodes)

    adj1, adj2 = asg.edge_data[vertex_1], asg.edge_data[vertex_2]

    if length(asg.edge_data[vertex_1]) >= hyperparams.teleportation_threshold
        distance = hyperparams.teleportation_distance
        vertex_1 = teleportation!(asg, vertex_1, pauli_tracker, hyperparams, distance)
    end
    if length(asg.edge_data[vertex_2]) >= hyperparams.teleportation_threshold
        distance = hyperparams.teleportation_distance
        vertex_2 = teleportation!(asg, vertex_2, pauli_tracker, hyperparams, distance)
    end

    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs!(asg, vertex_1, vertex_2, pauli_tracker, hyperparams)
    end
    if !check_almost_isolated(adj2, vertex_1)
        remove_sqs!(asg, vertex_2, vertex_1, pauli_tracker, hyperparams)
    end
    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs!(asg, vertex_1, vertex_2, pauli_tracker, hyperparams)
    end

    apply_cz_to_prepared_state(asg, vertex_1, vertex_2, pauli_tracker)
end

function cz_no_teleport(asg, vertex_1, vertex_2, pauli_tracker, hyperparams)
    # println("\nStarting applying cz_no_teleport! on qubits $(vertex_1) and $(vertex_2)! the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n pauli       $(asg.sqp)!")

    adj1, adj2 = asg.edge_data[vertex_1], asg.edge_data[vertex_2]

    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs_no_teleport!(asg, vertex_1, vertex_2, hyperparams)
    end
    if !check_almost_isolated(adj2, vertex_1)
        remove_sqs_no_teleport!(asg, vertex_2, vertex_1, hyperparams)
    end
    if !check_almost_isolated(adj1, vertex_2)
        remove_sqs_no_teleport!(asg, vertex_1, vertex_2, hyperparams)
    end

    apply_cz_to_prepared_state(asg, vertex_1, vertex_2, pauli_tracker)
end

"""
Assuming that the verticies CZ is acting on are either isolated or have sqs = I or S,
apply a CZ gate between those two gates. Only requires using lookup table.
"""
function apply_cz_to_prepared_state(asg, vertex_1, vertex_2, pauli_tracker)
    track_conditional_paulis_through_cz(pauli_tracker.cond_paulis, vertex_1, vertex_2)

    # println("\nFinally applying cz on qubits $(vertex_1) and $(vertex_2)! the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")

    connected = vertex_1 in asg.edge_data[vertex_2] || vertex_2 in asg.edge_data[vertex_1]

    clifford_1_table_code = asg.sqp[vertex_1] + 4 * (asg.sqs[vertex_1] - 1)
    clifford_2_table_code = asg.sqp[vertex_2] + 4 * (asg.sqs[vertex_2] - 1)
    table_tuple = cz_table[connected+1][clifford_1_table_code, clifford_2_table_code]

    # print("table_tuple is $(table_tuple)!\n")
    # print("table_tuple input was $(connected) and $clifford_1_table_code and $clifford_2_table_code \n")

    connected != table_tuple[1] && toggle_edge!(asg.edge_data, vertex_1, vertex_2)
    asg.sqp[vertex_1] = table_tuple[2][1]
    asg.sqs[vertex_1] = table_tuple[2][2]
    asg.sqp[vertex_2] = table_tuple[3][1]
    asg.sqs[vertex_2] = table_tuple[3][2]

    # println("After applying cz the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")
end


"""
Remove all single qubit clifford operations on a vertex v that do not
commute with CZ. Needs use of a neighbor of v, but if we wish to avoid
using a particular neighbor, we can specify it.

Args:
    sqs::Vector{UInt8}      single qubit clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index of the vertex to remove single qubit clifford operations from
    avoid::Int            index of a neighbor of v to avoid using
"""
function remove_sqs!(asg, v, avoid, pauli_tracker, hyperparams)
    # println("remove_sqs at node $v ! to remove $(asg.sqs[v]) with pauli $(asg.sqp[v])!")
    # println("remove_sqs at node $v ! the prepared graph state is:\n edge data $(asg.edge_data)\n symplectics $(asg.sqs)\n pauli $(asg.sqp)!")
    code = asg.sqs[v]
    if code == I_code || code == S_code
    elseif code == SQRT_X_code || code == HS_code
        local_complement_no_teleport!(asg, v)
    else # code == H_code || code == SH_code
        # almost all calls to remove_sqs!() will end up here
        neighbor = get_neighbor(asg.edge_data, v, avoid, hyperparams)
        local_complement_no_teleport!(asg, neighbor)
        local_complement_no_teleport!(asg, v)
    end
    # println("sqs at node $v is now $(asg.sqs[v]) with pauli $(asg.sqp[v])!")
end

function remove_sqs_no_teleport!(asg, v, avoid, hyperparams)
    code = asg.sqs[v]
    if code == I_code || code == S_code
    elseif code == SQRT_X_code || code == HS_code
        local_complement_no_teleport!(asg, v)
    else # code == H_code || code == SH_code
        # almost all calls to remove_sqs!() will end up here
        neighbor = get_neighbor(asg.edge_data, v, avoid, hyperparams)
        local_complement_no_teleport!(asg, neighbor)
        local_complement_no_teleport!(asg, v)
    end
end

"""
Select a neighbor to use when removing a single qubit clifford operation.

The return value be set to avoid if there are no neighbors or avoid is the only neighbor,
otherwise it returns the neighbor with the fewest neighbors (or the first one that
it finds with less than min_neighbors)
"""
function get_neighbor(adj, v, avoid, hyperparams)
    neighbors_of_v = adj[v]

    # Avoid copying and modifying adjacency vector
    check_almost_isolated(neighbors_of_v, avoid) && return avoid

    smallest_neighborhood_size = typemax(eltype(neighbors_of_v)) # initialize to max possible value
    neighbor_with_smallest_neighborhood = 0
    if length(neighbors_of_v) <= hyperparams.max_num_neighbors_to_search
        neighbors_to_search = neighbors_of_v
    else
        neighbors_to_search = sample(
            collect(neighbors_of_v),
            hyperparams.max_num_neighbors_to_search;
            replace=false
        )
    end

    for neighbor in neighbors_to_search
        if neighbor != avoid
            # stop search if super small neighborhood is found
            num_neighbors = length(adj[neighbor])
            num_neighbors < hyperparams.min_neighbors && return neighbor
            # search for smallest neighborhood
            if num_neighbors < smallest_neighborhood_size
                smallest_neighborhood_size = num_neighbors
                neighbor_with_smallest_neighborhood = neighbor
            end
        end
    end
    return neighbor_with_smallest_neighborhood
end


"""
Take the local complement of a vertex v.

Args:
    sqs::Vector{UInt8}      single qubit clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index node to take the local complement of
"""
function local_complement!(asg, v, pauli_tracker, hyperparams)
    if length(asg.edge_data[v]) >= hyperparams.teleportation_threshold
        distance = hyperparams.teleportation_distance
        v = teleportation!(asg, v, pauli_tracker, hyperparams, distance)
    end

    local_complement_no_teleport!(asg, v)
end

function local_complement_no_teleport!(asg, v)
    # println("Before local complement on $(v) the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")
    neighbors = collect(asg.edge_data[v])
    len = length(neighbors)
    multiply_sqrt_x_from_right(asg, v)
    for i = 1:len
        neighbor = neighbors[i]
        multiply_s_dagger_from_right(asg, neighbor)
        for j = i+1:len
            toggle_edge!(asg.edge_data, neighbor, neighbors[j])
        end
    end
    # println("After local complement on $(v) the prepared graph state is:\n edge data   $(asg.edge_data)\n symplectics $(asg.sqs)\n paulis      $(asg.sqp)!")
end


"""Add an edge between the two vertices given"""
@inline function add_edge!(adj, vertex_1, vertex_2)
    push!(adj[vertex_1], vertex_2)
    push!(adj[vertex_2], vertex_1)
end

"""Remove an edge between the two vertices given"""
@inline function remove_edge!(adj, vertex_1, vertex_2)
    delete!(adj[vertex_1], vertex_2)
    delete!(adj[vertex_2], vertex_1)
end

"""
If vertices vertex_1 and vertex_2 are connected, we remove the edge.
Otherwise, add it.

Args:
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         index of vertex to be connected or disconnected
    vertex_2::Int         index of vertex to be connected or disconnected
"""
function toggle_edge!(adj, vertex_1, vertex_2)
    if vertex_2 in adj[vertex_1]
        remove_edge!(adj, vertex_1, vertex_2)
    else
        add_edge!(adj, vertex_1, vertex_2)
    end
end

"""
Teleport your "oz qubit" with high degree to a "kansas qubit" with degree 1.
Speeds up computation by avoiding performing local complements on high degree nodes.

Args:
    sqs::Vector{UInt8}      single qubit clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    oz_qubit::Int         index of the qubit to teleport
    data_qubits::Dict       map from qubit indices to vertex indices
"""
function teleportation!(
    asg,
    oz_qubit,
    pauli_tracker,
    hyperparams,
    curr_teleportation_distance,
)
    # println("\n\n\nThere's no place like home! There's no place like home! There's no place like home!")
    slippers_qubit = Qubit(asg.n_nodes + 1) # facilitates teleportation
    kansas_qubit = Qubit(asg.n_nodes + 2) # qubit we teleport to
    asg.n_nodes += 2
    # println("oz_qubit is $(oz_qubit) and slippers_qubit is $(slippers_qubit) and kansas_qubit is $(kansas_qubit)!\n\n\n")
    add_new_qubit_to_pauli_tracker!(pauli_tracker)
    add_new_qubit_to_pauli_tracker!(pauli_tracker)

    # output state of H(slippers_qubit) * CX(slippers_qubit, kansas_qubit_qubit) * H(slippers_qubit)
    asg.sqs[slippers_qubit] = I_code
    asg.sqs[kansas_qubit] = I_code
    asg.edge_data[slippers_qubit] = AdjList(kansas_qubit)
    asg.edge_data[kansas_qubit] = AdjList(slippers_qubit)

    cz_no_teleport(asg, oz_qubit, slippers_qubit, pauli_tracker, hyperparams)
    multiply_h_from_left(asg, pauli_tracker, slippers_qubit)
    multiply_h_from_left(asg, pauli_tracker, oz_qubit)

    add_z_to_pauli_tracker!(pauli_tracker.cond_paulis, oz_qubit, kansas_qubit)
    add_measurement!(pauli_tracker.measurements, H_code, oz_qubit)
    add_x_to_pauli_tracker!(pauli_tracker.cond_paulis, slippers_qubit, kansas_qubit)
    add_measurement!(pauli_tracker.measurements, H_code, slippers_qubit)


    # update qubit map if needed
    for (i, qubit) in enumerate(asg.stitching_properties.gate_output_nodes)
        # println(qubit, " ", oz_qubit, " ", kansas_qubit)
        if qubit == oz_qubit
            asg.stitching_properties.gate_output_nodes[i] = kansas_qubit
        end
    end

    # println(asg.stitching_properties.gate_output_nodes)

    # peform multiple teleportations if we need distance > 2
    if curr_teleportation_distance > 2
        distance = curr_teleportation_distance - 2
        return teleportation!(asg, kansas_qubit, pauli_tracker, hyperparams, distance)
    end

    return kansas_qubit
end




#=
Some small utils for converting from python objects to Julia
=#

"""Get qubit index of python operation"""
get_qubit_1(op) = pyconvert(Int, op.qubit_indices[0]) + 1 # +1 because Julia is 1-indexed
get_qubit_2(op) = pyconvert(Int, op.qubit_indices[1]) + 1

"""Get Python version of op_list of to speed up getting index"""
get_op_list() = pylist(op_list)

"""Get index of operation name"""
get_op_index(op_list, op) = pyconvert(Int, op_list.index(op.gate.name)) + 1

pauli_op(index) = 0 <= index < 7 # i.e. I, X, Y, Z
single_qubit_op(index) = index < 10   # Paulis, H, S, S_Dagger
double_qubit_op(index) = 10 <= index < 12  # CZ, CNOT
decompose_op(index) = index >= 12 # T, T_Dagger, RX, RY, RZ
