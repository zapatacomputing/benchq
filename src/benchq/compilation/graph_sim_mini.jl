################################################################################
# © Copyright 2022-2023 Zapata Computing Inc.
################################################################################
#=
This module contains functions for getting the graph state corresponding to a
state generated by a circuit using a graph state simulator (graph_sim) from the paper
"Fast simulation of stabilizer circuits using a graph state representation" by Simon
Anders, Hans J. Briegel. https://arxiv.org/abs/quant-ph/0504117"
=#

using Jabalizer
using TimerOutputs

const to = TimerOutput()

include("graph_sim_data.jl")

const AdjList = Set{Int32}

const Qubit = UInt32

struct ICMOp
    code::LCO
    qubit1::Qubit
    qubit2::Qubit

ICMOp(name, qubit) = new(name, qubit+1, 0)
ICMOp(name, qubit1, qubit2) = new(name, qubit1+1, qubit2+1)
end

"""
Get the vertices of a graph state corresponding to enacting the given circuit
on the |0> state. Also gives the local clifford operation on each node.

Args:
    circuit (Circuit): circuit to get the graph state for

Raises:
    ValueError: if an unsupported gate is encountered

Returns:
    Vector{LCO}: the list of local clifford operations on each node
    Vector{AdjList}:   the adjacency list describing the graph corresponding to the graph state
"""
function get_graph_state_data(icm_circuit::Vector{ICMOp}, n_qubits)
    lco = fill(H_code, n_qubits)   # local clifford operation on each node
    adj = [AdjList() for _ in 1:n_qubits]  # adjacency list

    #=
    # for keeping track of progress
    total_length = length(icm_circuit)
    last_10_percent_completed = 0
    i = 0
    =#

    for icm_op in icm_circuit
        #=
        i += 1
        percent_completed = round(100 * i / total_length)
        if percent_completed >= last_10_percent_completed + 10
            println("GraphSim Mini is $percent_completed% completed")
            last_10_percent_completed += 10
        end
        =#

        op_code = icm_op.code
        qubit_1 = icm_op.qubit1
        if op_code == H_code
            lco[qubit_1] = multiply_h[lco[qubit_1]]
        elseif op_code == S_code
            lco[qubit_1] = multiply_s[lco[qubit_1]]
        elseif op_code == CNOT_code
            # CNOT = (I ⊗ H) CZ (I ⊗ H)
            qubit_2 = icm_op.qubit2
            lco[qubit_2] = multiply_h[lco[qubit_2]]
            @timeit to "cz" cz(lco, adj, qubit_1, qubit_2)
            lco[qubit_2] = multiply_h[lco[qubit_2]]
        elseif op_code == CZ_code
            @timeit to "cz" cz(lco, adj, qubit_1, icm_op.qubit2)
        else # S_Dagger_code
            lco[qubit_1] = multiply_d[lco[qubit_1]]
        end
    end

    return lco, adj
end

"""Unpacks the values in the cz table and updates the lco values)"""
@inline function update_lco(table, lco, vertex_1, vertex_2)
    # Get the packed value from the table
    val = table[lco[vertex_1], lco[vertex_2]]
    # The code for the first vertex is stored in the top byte, and the second in the bottom byte
    lco[vertex_1] = (val >> 8) & 0x7f
    lco[vertex_2] = val & 0xff
    # return if the top bit is set, which indicates if it is isolated or connected
    (val & 0x8000) != 0x0000
end

"""
Check if a vertex is almost isolated. A vertex is almost isolated if it has no
neighbors or if it has one neighbor and that neighbor is the given vertex.

Args:
    set::AdjList set of neighbors of a vertex
    vertex::Int  vertex to check if it is almost isolated

Returns:
    Bool: whether the vertex is almost isolated
"""
function check_almost_isolated(set, vertex)
    len = length(set)
    return (len == 0) || (len == 1 && vertex in set)
end

"""
Apply a CZ gate to the graph on the given vertices.

Args:
    lco::Vector{LCO}      local clifford operation on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         vertex to enact the CZ gate on
    vertex_2::Int         vertex to enact the CZ gate on
"""
function cz(lco, adj, vertex_1, vertex_2)
    lst1, lst2 = adj[vertex_1], adj[vertex_2]

    if check_almost_isolated(lst1, vertex_2)
        check_almost_isolated(lst2, vertex_1) || remove_lco(lco, adj, vertex_2, vertex_1)
        # if you don't remove vertex_2 from lst1, then you don't need to check again
    else
        remove_lco(lco, adj, vertex_1, vertex_2)
        if !check_almost_isolated(lst2, vertex_1)
            remove_lco(lco, adj, vertex_2, vertex_1)
            # recheck the adjacency list of vertex_1, because it might have been removed
            check_almost_isolated(lst1, vertex_2) || remove_lco(lco, adj, vertex_1, vertex_2)
        end
    end
    if vertex_2 in lst1
        update_lco(cz_connected, lco, vertex_1, vertex_2) || remove_edge!(adj, vertex_1, vertex_2)
    else
        update_lco(cz_isolated, lco, vertex_1, vertex_2) && add_edge!(adj, vertex_1, vertex_2)
    end
end

#=
function get_neighbor(neighbors, avoid)
    # Avoid copying and modifying adjacency vector
    # vb will be set to avoid if there are no neighbors, or avoid is the only neighbor,
    # otherwise it will pick the first neighbor it sees that is not avoid
    isempty(neighbors) && return avoid
    vb = neighbors[1]
    # if there is only one element, or the first element is not avoid, just return it,
    # otherwise, pick the second element
    (length(neighbors) == 1 || vb != avoid) ? vb : neighbors[2]
end
=#

function get_neighbor(neighbors, avoid)
    # Avoid copying and modifying adjacency vector
    # vb will be set to avoid if there are no neighbors, or avoid is the only neighbor,
    # otherwise it will pick the first neighbor it sees that is not avoid
    isempty(neighbors) && return avoid
    # This is looking into the internal Set implementation for optimal speed!
    dict = neighbors.dict
    slots = dict.slots
    for i = dict.idxfloor:length(slots)
        @inbounds if slots[i] == 0x1 # make sure slot is actually filled
            vb = dict.keys[i]
            vb != avoid && return vb
        end
    end
    avoid
end

"""
Remove all local clifford operations on a vertex v. Needs use of a neighbor
of v, but if we wish to avoid using a particular neighbor, we can specify it.

Args:
    lco::Vector{LCO}      local clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index of the vertex to remove local clifford operations from
    avoid::Int            index of a neighbor of v to avoid using
"""
function remove_lco(lco, adj, v, avoid)
    #=
    other_neighbors = deepcopy(adj[v])
    delete!(other_neighbors, avoid)
    vb = isempty(other_neighbors) ? avoid : pop!(other_neighbors)

    for factor in reverse(decomposition_lookup_table[lco[v]])
        local_complement(lco, adj, factor == 'U' ? v : vb)
    end
    =#
    @timeit to "remove_lco" begin
    # This uses a precomputed decomposition table, length is stored in top 3 bits
    # Other 5 bits when set indicate using sqrt(Z) gate instead of sqrt(X) gate
    tab = decomp_tab[lco[v]]
    if (tab & 0x1f) == 0 # check if there are any sqrt(Z) gates
        # Faster code for 4 of the 24 gates that don't have sqrt(Z)
        for i = 1:(tab>>5)
            local_complement!(lco, adj, v)
        end
    else
        vb = get_neighbor(adj[v], avoid)
        for i = 1:(tab>>5)
            local_complement!(lco, adj, ifelse((tab & 0x1) == 0x0, v, vb))
            tab >>= 1
        end
    end
    end
end


"""
Take the local complement of a vertex v.

Args:
    lco::Vector{LCO}      local clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index node to take the local complement of
"""
function local_complement!(lco, adj, v)
    @timeit to "lc toggle" begin
    neighbors = collect(adj[v])
    len = length(neighbors)
    for i in 1:len, j in i+1:len
        toggle_edge!(adj, neighbors[i], neighbors[j])
    end
    end

    @timeit to "lc multiply lco" begin
    lco[v] = multiply_by_sqrt_x[lco[v]]
    for i in adj[v]
        lco[i] = multiply_by_s[lco[i]]
    end
    end
end

"""Add an edge between the two vertices given"""
@inline function add_edge!(adj, vertex_1, vertex_2)
    #=
    lst1, lst2 = adj[vertex_1], adj[vertex_2]
    insert!(lst1, searchsortedfirst(lst1, vertex_2), vertex_2)
    insert!(lst2, searchsortedfirst(lst2, vertex_1), vertex_1)
    =#
    push!(adj[vertex_1], vertex_2)
    push!(adj[vertex_2], vertex_1)
end    

"""Remove an edge between the two vertices given"""
@inline function remove_edge!(adj, vertex_1, vertex_2)
    #=
    lst1, lst2 = adj[vertex_1], adj[vertex_2]
    deleteat!(lst1, searchsortedfirst(lst1, vertex_2))
    deleteat!(lst2, searchsortedfirst(lst2, vertex_1))
    =#
    delete!(adj[vertex_1], vertex_2)
    delete!(adj[vertex_2], vertex_1)
end

"""
If vertices vertex_1 and vertex_2 are connected, we remove the edge.
Otherwise, add it.

Args:
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         index of vertex to be connected or disconnected
    vertex_2::Int         index of vertex to be connected or disconnected
"""
function toggle_edge!(adj, vertex_1, vertex_2)
    # if insorted(vertex_2, adj[vertex_1])
    if vertex_2 in adj[vertex_1]
        remove_edge!(adj, vertex_1, vertex_2)
    else
        add_edge!(adj, vertex_1, vertex_2)
    end
end

get_qubit_1(op) = Jabalizer.pyconvert(Int, op.qubit_indices[0])
get_qubit_2(op) = Jabalizer.pyconvert(Int, op.qubit_indices[1])

const op_list = ["I", "X", "Y", "Z", "H", "S", "S_Dagger", "CZ", "CNOT",
                 "T", "T_Dagger", "RX", "RY", "RZ"]
const code_list = LCO[0, 0, 0, 0, H_code, S_code, S_Dagger_code, CZ_code, CNOT_code,
                      T_code, T_Dagger_code, RX_code, RY_code, RZ_code]

"""Get Python version of op_list of to speed up getting index"""
get_op_list() = Jabalizer.pylist(op_list)

"""Get index of operation name"""
get_op_index(op_list, op) = Jabalizer.pyconvert(Int, op_list.index(op.gate.name)) + 1

ignore_op(index) = index < 5 # i.e. I, X, Y, Z
single_qubit_op(index) = 4 < index < 8   # H, S, S_Dagger
double_qubit_op(index) = 7 < index < 10  # CZ, CNOT
decompose_op(index) = index > 9 # T, T_Dagger, RX, RY, RZ

"""
Performs gates decomposition to provide a circuit in the icm format.
Reference: https://arxiv.org/abs/1509.02004
"""
function get_icm(circuit, n_qubits::Int, with_measurements::Bool=false)
    # mapping from qubit to its compiled version
    qubit_map = [Qubit(i) for i = 0:n_qubits-1]
    compiled_circuit = ICMOp[]
    ops = get_op_list()
    curr_qubits = n_qubits
    for op in circuit
        op_index = get_op_index(ops, op)
        if single_qubit_op(op_index)
            push!(compiled_circuit, ICMOp(code_list[op_index], qubit_map[get_qubit_1(op)+1]))
        elseif double_qubit_op(op_index)
            push!(compiled_circuit,
                  ICMOp(code_list[op_index],
                        qubit_map[get_qubit_1(op)+1], qubit_map[get_qubit_2(op)+1]))
        elseif decompose_op(op_index)
            # Note: these are currently all single qubit gates
            original_qubit = get_qubit_1(op)
            compiled_qubit = qubit_map[original_qubit+1]
            qubit_map[original_qubit+1] = new_qubit = curr_qubits
            curr_qubits += 1

            push!(compiled_circuit, ICMOp(CNOT_code, compiled_qubit, new_qubit))
            with_measurements &&
                push!(compiled_circuit,
                      ICMOp(code_list[op_index]+MEASURE_OFFSET, compiled_qubit, new_qubit))
        end
    end

    return compiled_circuit, curr_qubits
end

"""
Destructively convert this to a Python adjacency list
"""
function python_adjlist!(adj)
    #=
    # Use this to free up memory if possible when converting to a Python list
    empty_adj = AdjList()
    py_adj = Jabalizer.pylist()
    for i = 1:length(adj)
        lst = adj[i]
        adj[i] = empty_adj # let it be garbage collected as soon as possible
        # build up Python list of adjacency lists
        py_adj.append(Jabalizer.pylist(lst .- 1))
    end
    py_adj
    =#
    Jabalizer.pylist([Jabalizer.pylist(adj[i] .- 1) for i in 1:length(adj)])
end

"""
Converts a given circuit in Clifford + T form to icm form and simulates the icm 
circuit using the graph sim mini simulator. Returns the adjacency list of the graph
state created by the icm circuit along with the single qubit operations on each vertex.

Args:
    circuit::Circuit  circuit to be simulated

Returns:
    adj::Vector{AdjList}  adjacency list describing the graph state
    lco::Vector{LCO}      local clifford operations on each node
"""
function _run_graph_sim_mini(circuit)
    n_qubits = Jabalizer.pyconvert(Int, circuit.n_qubits)
    ops = circuit.operations
    print("ICM compilation: qubits=$n_qubits, gates=$(length(ops))\n\t")
    @time (icm_circuit, icm_n_qubits) = get_icm(ops, n_qubits)
    print("Graph Sim Mini: qubits=$icm_n_qubits, gates=$(length(icm_circuit))\n\t")
    @time (lco, adj) = get_graph_state_data(icm_circuit, icm_n_qubits)
    py_lco = Jabalizer.pylist(lco)
    print("Convert adj:\n\t")
    @time py_adj = python_adjlist!(adj)
    println()
    return py_lco, py_adj
end

include("old_graph_sim_mini.jl")

function run_graph_sim_mini(circuit)
    println("\nNew graph code:\n")
    @time res = _run_graph_sim_mini(circuit)
    show(to)
    reset_timer!(to)
    println("\n\nOld graph code:\n")
    @time res2 = OldSimMini._run_graph_sim_mini(circuit)
    return res
end
