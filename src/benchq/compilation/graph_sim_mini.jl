################################################################################
# Â© Copyright 2022-2023 Zapata Computing Inc.
################################################################################
#=
This module contains functions for getting the graph state corresponding to a
state generated by a circuit using a graph state simulator (graph_sim) from the paper
"Fast simulation of stabilizer circuits using a graph state representation" by Simon
Anders, Hans J. Briegel. https://arxiv.org/abs/quant-ph/0504117"
=#

using Jabalizer

include("graph_sim_data.jl")

const AdjList = Set{Int32}

const Qubit = UInt32

struct ICMOp
    name::String
    qubit1::Qubit
    qubit2::Qubit

ICMOp(name, qubit) = new(name, qubit+1, 0)
ICMOp(name, qubit1, qubit2) = new(name, qubit1+1, qubit2+1)
end

"""
Get the vertices of a graph state corresponding to enacting the given circuit
on the |0> state. Also gives the local clifford operation on each node.

Args:
    circuit (Circuit): circuit to get the graph state for

Raises:
    ValueError: if an unsupported gate is encountered

Returns:
    Vector{LCO}: the list of local clifford operations on each node
    Vector{AdjList}:   the adjacency list describing the graph corresponding to the graph state
"""
function get_graph_state_data(icm_circuit::Vector{ICMOp}, n_qubits)
    lco = fill(H_code, n_qubits)   # local clifford operation on each node
    adj = [AdjList() for _ in 1:n_qubits]  # adjacency list

    # for keeping track of progress
    total_length = length(icm_circuit)
    last_10_percent_completed = 0
    i = 0

    for icm_op in icm_circuit
        i += 1
        percent_completed = round(100 * i / total_length)
        if percent_completed >= last_10_percent_completed + 10
            println("GraphSim Mini is $percent_completed% completed")
            last_10_percent_completed += 10
        end

        op_name = icm_op.name
        qubit_1 = icm_op.qubit1
        if op_name == "H"
            lco[qubit_1] = multiply_h[lco[qubit_1]]
        elseif op_name == "S"
            lco[qubit_1] = multiply_s[lco[qubit_1]]
        elseif op_name == "CNOT"
            # CNOT = (I \otimes H) CZ (I \otimes H)
            qubit_2 = icm_op.qubit2
            lco[qubit_2] = multiply_h[lco[qubit_2]]
            cz(lco, adj, qubit_1, qubit_2)
            lco[qubit_2] = multiply_h[lco[qubit_2]]
        elseif op_name == "CZ"
            cz(lco, adj, qubit_1, icm_op.qubit2)
        else # "S_Dagger"
            lco[qubit_1] = multiply_d[lco[qubit_1]]
        end
    end

    return lco, adj
end

"""Unpacks the values in the cz table and updates the lco values)"""
@inline function update_lco(table, lco, vertex_1, vertex_2)
    val = table[lco[vertex_1], lco[vertex_2]]
    lco[vertex_1] = (val >> 8) & 0x7f
    lco[vertex_2] = val & 0xff
    (val & 0x8000) != 0x0000
end

"""
Apply a CZ gate to the graph on the given vertices.

Args:
    lco::Vector{LCO}      local clifford operation on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         vertex to enact the CZ gate on
    vertex_2::Int         vertex to enact the CZ gate on
"""
function cz(lco, adj, vertex_1, vertex_2)
    check_almost_isolated(adj[vertex_1], vertex_2) || remove_lco(lco, adj, vertex_1, vertex_2)
    check_almost_isolated(adj[vertex_2], vertex_1) || remove_lco(lco, adj, vertex_2, vertex_1)
    check_almost_isolated(adj[vertex_1], vertex_2) || remove_lco(lco, adj, vertex_1, vertex_2)

    if vertex_2 in adj[vertex_1]
        update_lco(cz_connected, lco, vertex_1, vertex_2) || remove_edge!(adj, vertex_1, vertex_2)
    else
        update_lco(cz_isolated, lco, vertex_1, vertex_2) && add_edge!(adj, vertex_1, vertex_2)
    end
end


"""
Check if a vertex is almost isolated. A vertex is almost isolated if it has no
neighbors or if it has one neighbor and that neighbor is the given vertex.

Args:
    set::AdjList set of neighbors of a vertex
    vertex::Int  vertex to check if it is almost isolated

Returns:
    Bool: whether the vertex is almost isolated
"""
function check_almost_isolated(set, vertex)
    len = length(set)
    return (len == 0) || (len == 1 && vertex in set)
end

function get_neighbor(neighbors, avoid)
    # Avoid copying and modifying adjacency vector
    # vb will be set to avoid if there are no neighbors, or avoid is the only neighbor,
    # otherwise it will pick the first neighbor it sees that is not avoid
    isempty(neighbors) && return avoid
    # This is looking into the internal Set implementation for optimal speed!
    dict = neighbors.dict
    slots = dict.slots
    for i = dict.idxfloor:length(slots)
        @inbounds if slots[i] == 0x1 # make sure slot is actually filled
            vb = dict.keys[i]
            vb != avoid && return vb
        end
    end
    avoid
end


"""
Remove all local clifford operations on a vertex v. Needs use of a neighbor
of v, but if we wish to avoid using a particular neighbor, we can specify it.

Args:
    lco::Vector{LCO}      local clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index of the vertex to remove local clifford operations from
    avoid::Int            index of a neighbor of v to avoid using
"""
function remove_lco(lco, adj, v, avoid)
    #=
    other_neighbors = deepcopy(adj[v])
    delete!(other_neighbors, avoid)
    vb = isempty(other_neighbors) ? avoid : pop!(other_neighbors)

    for factor in reverse(decomposition_lookup_table[lco[v]])
        local_complement(lco, adj, factor == 'U' ? v : vb)
    end
    =#
    # This uses a precomputed decomposition table, length is stored in top 3 bits
    # Other 5 bits when set indicate using sqrt(Z) gate instead of sqrt(X) gate
    tab = decomp_tab[lco[v]]
    if tab & 0x1f # check if there are any sqrt(Z) gates
        vb = get_neighbor(adj[v], avoid)
        for i = 1:(tab>>5)
            local_complement!(lco, adj, ifelse((tab & 0x1) == 0x0, v, vb))
            tab >>= 1
        end
    else
        # Faster code for 4 of the 24 gates that don't have sqrt(Z)
        for i = 1:(tab>>5)
            local_complement!(lco, adj, v)
        end
    end
end


"""
Take the local complement of a vertex v.

Args:
    lco::Vector{LCO}      local clifford operations on each node
    adj::Vector{AdjList}  adjacency list describing the graph state
    v::Int                index node to take the local complement of
"""
function local_complement!(lco, adj, v)
    neighbors = collect(adj[v])
    len = length(neighbors)
    for i in 1:len, j in i+1:len
        toggle_edge!(adj, neighbors[i], neighbors[j])
    end

    lco[v] = multiply_by_sqrt_x[lco[v]]
    for i in adj[v]
        lco[i] = multiply_by_s[lco[i]]
    end
end

"""Add an edge between the two vertices given"""
@inline function add_edge!(adj, vertex_1, vertex_2)
    push!(adj[vertex_1], vertex_2)
    push!(adj[vertex_2], vertex_1)
end    

"""Remove an edge between the two vertices given"""
@inline function remove_edge!(adj, vertex_1, vertex_2)
    delete!(adj[vertex_1], vertex_2)
    delete!(adj[vertex_2], vertex_1)
end

"""
If vertices vertex_1 and vertex_2 are connected, we remove the edge.
Otherwise, add it.

Args:
    adj::Vector{AdjList}  adjacency list describing the graph state
    vertex_1::Int         index of vertex to be connected or disconnected
    vertex_2::Int         index of vertex to be connected or disconnected
"""
function toggle_edge!(adj, vertex_1, vertex_2)
    if vertex_2 in adj[vertex_1]
        remove_edge!(adj, vertex_1, vertex_2)
    else
        add_edge!(adj, vertex_1, vertex_2)
    end
end

# Change this find the op out of a table, don't create a new string for every op
"""Get op name as Julia string"""
get_op_name(op) = Jabalizer.pyconvert(String, op.gate.name)

"""Get qubit(s) as a tuple"""
function get_qubit(op)
    indices = op.qubit_indices
    len = length(indices)
    if len == 1
        return ( Jabalizer.pyconvert(Int, indices[0]), 0 )
    elseif len == 2
        return ( Jabalizer.pyconvert(Int, indices[0]), Jabalizer.pyconvert(Int, indices[1]) )
    else
        error("Invalid number of qubits $len")
    end
end

"""
Performs gates decomposition to provide a circuit in the icm format.
Reference: https://arxiv.org/abs/1509.02004
"""
function get_icm(
    circuit,
    n_qubits::Int,
    gates_to_decompose::Vector{String},
    with_measurements::Bool=false
)
    # mapping from qubit to its compiled version
    qubit_map = [Qubit(i) for i = 0:n_qubits-1]
    compiled_circuit = ICMOp[]
    curr_qubits = n_qubits
    for op in circuit
        op_name = get_op_name(op)
        if op_name in ["I", "X", "Y", "Z"]
            continue
        elseif op_name == "H" || op_name == "S" || op_name == "S_Dagger"
            push!(compiled_circuit,
                  ICMOp(op_name, qubit_map[op_gates[1]+1]))
        elseif op_name == "CNOT" || op_name == "CZ"
            push!(compiled_circuit,
                  ICMOp(op_name, qubit_map[op_gates[1]+1], qubit_map[op_gates[2]+1]))
        elseif op_name in gates_to_decompose
            for original_qubit in op_gates
                compiled_qubit = qubit_map[original_qubit+1]
                qubit_map[original_qubit+1] = new_qubit = curr_qubits
                curr_qubits += 1

                push!(compiled_circuit, ICMOp("CNOT", compiled_qubit, new_qubit))
                if with_measurements
                    push!(compiled_circuit,
                          ICMOp("$(op_name)_measurement", compiled_qubit))
                    push!(compiled_circuit,
                          ICMOp("Gate_Conditioned_on_$(compiled_qubit)_Measurement", new_qubit))
                end
            end
        else
            error("Unknown gate: $op_name")
        end
    end

    return compiled_circuit, curr_qubits
end

"""
Converts a given circuit in Clifford + T form to icm form and simulates the icm 
circuit using the graph sim mini simulator. Returns the adjacency list of the graph
state created by the icm circuit along with the single qubit operations on each vertex.

Args:
    circuit::Circuit  circuit to be simulated

Returns:
    adj::Vector{AdjList}  adjacency list describing the graph state
    lco::Vector{LCO}      local clifford operations on each node
"""
function run_graph_sim_mini(circuit)
    print("ICM compilation: qubits=$n_qubits, gates=$(length(bare_circuit))\n\t")
    @time (icm_circuit, icm_n_qubits) = get_icm(circuit.operations,
                                                Jabalizer.pyconvert(Int, circuit.n_qubits),
                                                ["T", "T_Dagger", "RX", "RY", "RZ"])

    print("Graph Sim Mini: qubits=$icm_n_qubits, gates=$(length(icm_circuit))\n\t")
    @time lco, adj = get_graph_state_data(icm_circuit, icm_n_qubits)

    println("Graph Sim Mini finished")
    return Jabalizer.pylist(lco), python_adjlist!(adj)
end

"""
Destructively convert this to a Python adjacency list
"""
function python_adjlist!(adj)
    # Use this to free up memory if possible when converting to a Python list
    empty_adj = AdjList()
    py_adj = Jabalizer.pylist()
    for i = 1:length(adj)
        lst = adj[i]
        adj[i] = empty_adj # let it be garbage collected as soon as possible
        # subtract 1 to convert to 0-indexing
        lst .-= 1
        # build up Python list of adjacency lists
        py_adj.append(Jabalizer.pylist(lst))
    end
    py_adj
end
