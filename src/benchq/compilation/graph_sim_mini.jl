################################################################################
# Â© Copyright 2022-2023 Zapata Computing Inc.
################################################################################
"""This module contains functions for getting the graph state corresponding to a
state generated by a circuit using a graph state simulator (graph_sim) from the paper
"Fast simulation of stabilizer circuits using a graph state representation" by Simon
Anders, Hans J. Briegel. https://arxiv.org/abs/quant-ph/0504117"
"""

using Jabalizer
using PythonCall

include("graph_sim_data.jl")


# numbers which correspond to each of the gates in multiply_lco
H_code = 11
S_code = 7
S_Dagger_code = 6
sqrt_X_code = 15

"""Get the vertices of a graph state corresponding to enacting the given circuit
on the |0> state. Also gives the local clifford operation on each node.

Args:
    circuit (Circuit): circuit to get the graph state for

Raises:
    ValueError: if an unsupported gate is encountered

Returns:
    List[int]: the list of local clifford operations on each node
    List[Set[int]]: the adjacency list describing the graph corresponding to the
        graph state
"""
function get_graph_state_data(icm_circuit, n_qubits)
    lco = [H_code for _ in 1:n_qubits]  # local clifford operation on each node
    adj = [Set{Int}() for _ in 1:n_qubits]  # adjacency list

    # for keeping track of progress
    total_length = length(icm_circuit)
    last_10_percent_completed = 0
    i = 0

    for (op_name, op_qubits) in icm_circuit
        i += 1
        percent_completed = round(100 * i / total_length)
        if percent_completed >= last_10_percent_completed + 10
            println("GraphSim Mini is $percent_completed% completed")
            last_10_percent_completed += 10
        end

        qubit_1 = parse(Int, op_qubits[1]) + 1
        if op_name in ["I", "X", "Y", "Z"]
            # these gates do not change the graph
            continue
        elseif op_name == "H"
            lco[qubit_1] = multiply_lco[H_code, lco[qubit_1]]
        elseif op_name == "S"
            lco[qubit_1] = multiply_lco[S_code, lco[qubit_1]]
        elseif op_name == "S_Dagger"
            lco[qubit_1] = multiply_lco[S_Dagger_code, lco[qubit_1]]
        elseif op_name == "CZ"
            cz(lco, adj, qubit_1, parse(Int, op_qubits[2]) + 1)
        elseif op_name == "CNOT"
            # CNOT = (I \otimes H) CZ (I \otimes H)
            qubit_2 = parse(Int, op_qubits[2]) + 1
            lco[qubit_2] = multiply_lco[H_code, lco[qubit_2]]
            cz(lco, adj, qubit_1, qubit_2)
            lco[qubit_2] = multiply_lco[H_code, lco[qubit_2]]
        else
            error("Unknown gate: $op_name")
        end
    end

    return lco, adj
end


"""Apply a CZ gate to the graph on the given vertices.

Args:
    lco (List[int]): local clifford operation on each node
    adj (List[Set[int]]): adjacency list describing the graph state
    vertex_1 (int): vertex to enact the CZ gate on
    vertex_2 (int): vertex to enact the CZ gate on
"""
function cz(lco, adj, vertex_1, vertex_2)
    check_almost_isolated(adj[vertex_1], vertex_2) && remove_lco(lco, adj, vertex_1, vertex_2)
    check_almost_isolated(adj[vertex_2], vertex_1) && remove_lco(lco, adj, vertex_2, vertex_1)
    check_almost_isolated(adj[vertex_1], vertex_2) && remove_lco(lco, adj, vertex_1, vertex_2)

    connected = vertex_1 in adj[vertex_2] || vertex_2 in adj[vertex_1]
    table_tuple = cz_table[connected+1][lco[vertex_1], lco[vertex_2]]

    connected != table_tuple[1] && toggle_edge(adj, vertex_1, vertex_2)
    lco[vertex_1] = table_tuple[2]
    lco[vertex_2] = table_tuple[3]
end


"""Check if a vertex is almost isolated. A vertex is almost isolated if it has no
neighbors or if it has one neighbor and that neighbor is the given vertex.

Args:
    set (Set[int]): set of neighbors of a vertex
    vertex (int): vertex to check if it is almost isolated

Returns:
    bool: whether the vertex is almost isolated
"""
function check_almost_isolated(set, vertex)
    l = length(set)
    return l != 0 || (l == 1 && vertex in set)
end


"""Remove all local clifford operations on a vertex v. Needs use of a neighbor
of v, but if we wish to avoid using a particular neighbor, we can specify it.

Args:
    lco (List[int]): local clifford operations on each node
    adj (List[Set[int]]): adjacency list describing the graph state
    v (int): index of the vertex to remove local clifford operations from
    avoid (int): index of a neighbor of v to avoid using
"""
function remove_lco(lco, adj, v, avoid)
    other_neighbors = deepcopy(adj[v])
    delete!(other_neighbors, avoid)
    vb = isempty(other_neighbors) ? avoid : pop!(other_neighbors)

    for factor in reverse(decomposition_lookup_table[lco[v]])
        local_complement(lco, adj, factor == 'U' ? v : vb)
    end
end


"""Take the local complement of a vertex v.

Args:
    lco (List[int]): local clifford operations on each node
    adj (List[Set[int]]): adjacency list describing the graph state
    v (int): index node to take the local complement of
"""
function local_complement(lco, adj, v)
    neighbors = collect(adj[v])
    for i in 1:length(neighbors)
        for j in i+1:length(neighbors)
            toggle_edge(adj, neighbors[i], neighbors[j])
        end
    end

    lco[v] = multiply_lco[lco[v], sqrt_X_code]
    for i in adj[v]
        lco[i] = multiply_lco[lco[i], S_code]
    end
end


"""If vertices vertex_1 and vertex_2 are connected, we remove the edge.
Otherwise, add it.

Args:
    adj (List[Set[int]]): adjacency list describing the graph state
    vertex_1 (int): index of vertex to be connected or disconnected
    vertex_2 (int): index of vertex to be connected or disconnected
"""
function toggle_edge(adj, vertex_1, vertex_2)
    if vertex_2 in adj[vertex_1] || vertex_1 in adj[vertex_2]
        delete!(adj[vertex_1], vertex_2)
        delete!(adj[vertex_2], vertex_1)
    else
        push!(adj[vertex_1], vertex_2)
        push!(adj[vertex_2], vertex_1)
    end
end


const ICMGate = Tuple{String,Vector{String}}

"""
Perfoms gates decomposition to provide a circuit in the icm format.
Reference: https://arxiv.org/abs/1509.02004
"""
function get_icm(
    circuit::Vector{ICMGate},
    n_qubits::Int,
    gates_to_decompose::Vector{String},
    with_measurements::Bool=false
)
    qubit_dict = Dict()  # mapping from qubit to it's compiled version
    compiled_circuit::Vector{ICMGate} = []
    curr_qubits = n_qubits
    for gate in circuit
        compiled_qubits = [get(qubit_dict, qubit, qubit) for qubit in gate[2]]

        if gate[1] in gates_to_decompose
            for (original_qubit, compiled_qubit) in zip(gate[2], compiled_qubits)
                new_qubit_name = "$(curr_qubits)"
                curr_qubits += 1

                qubit_dict[original_qubit] = new_qubit_name
                push!(compiled_circuit, ("CNOT", [compiled_qubit, new_qubit_name]))
                if with_measurements
                    push!(compiled_circuit,
                        ("$(gate[1])_measurement", [compiled_qubit]))
                    push!(compiled_circuit,
                        ("Gate_Conditioned_on_$(compiled_qubit)_Measurement",
                            [new_qubit_name]))
                end
            end
        else
            push!(compiled_circuit, (gate[1], compiled_qubits))
        end
    end

    return compiled_circuit, curr_qubits
end


"""Converts a given circuit in Clifford + T form to icm form and simulates the icm 
circuit using the graph sim mini simulator. Returns the adjacency list of the graph
state created by the icm circuit along with the single qubit operations on each vertex.

Args:
    circuit (Circuit): circuit to be simulated

Returns:    
    adj (List[Set[int]]): adjacency list describing the graph state
    lco (List[int]): local clifford operations on each node
"""
function run_graph_sim_mini(circuit)
    n_qubits = Jabalizer.pyconvert(Int, circuit.n_qubits)
    bare_circuit = Jabalizer.ICMGate[]
    for op in circuit.operations
        name = Jabalizer.pyconvert(String, op.gate.name)
        indices = [string(Jabalizer.pyconvert(Int, qubit)) for qubit in op.qubit_indices]
        push!(bare_circuit, (name, indices))
    end

    print("ICM compilation: qubits=$n_qubits, gates=$(length(bare_circuit))\n\t")
    @time (icm_circuit, icm_n_qubits) = get_icm(bare_circuit, n_qubits, ["T", "T_Dagger", "RX", "RY", "RZ"])

    print("Graph Sim Mini: qubits=$icm_n_qubits, gates=$(length(icm_circuit))\n\t")
    @time loc, adj = get_graph_state_data(icm_circuit, icm_n_qubits)

    println("Graph Sim Mini finished")

    py_adj = pylist([pylist(adj[i] .- 1) for i in 1:length(adj)]) # subtract 1 to convert to 0-indexing
    py_loc = pylist(loc)

    return py_loc, py_adj
end


const ICMGate = Tuple{String,Vector{String}}
